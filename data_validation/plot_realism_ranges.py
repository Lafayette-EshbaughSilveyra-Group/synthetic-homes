import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.stats import ks_2samp
import math


# Paths
GEN_CSV = "building_params.csv"  # generated by extract_distributions_dataset.py (now normalized to SI in save_csv_json)
RANGE_CSV = os.path.join("resstock", "options_saturations_summary.csv")
OUT_DIR = "realism_figures"

os.makedirs(OUT_DIR, exist_ok=True)


# (name, gen_col, summary_metric, xlabel)
VARIABLES = [
    ("R_wall",   "R_wall",   "R_wall_SI",      "Wall R-value (m²·K/W)"),
    ("R_roof",   "R_roof",   "R_roof_SI",      "Roof/Attic R-value (m²·K/W)"),
    ("COP_cool", "COP_cool", "COP_cool",       "Cooling efficiency (COP)"),
    ("COP_heat", "COP_heat", "COP_heat_like",  "Heating efficiency (–)")
]


def sample_from_quantiles(q10: float, q50: float, q90: float, size: int) -> np.ndarray:
    """Create a synthetic reference sample using a triangular distribution
    with support [q10, q90] and mode at q50. If inputs are invalid, returns empty array."""
    if any(map(lambda v: (v is None) or (isinstance(v, float) and math.isnan(v)), [q10, q50, q90])):
        return np.array([])
    if not (q10 < q50 < q90):
        return np.array([])
    # numpy.random.triangular expects a<=mode<=b
    return np.random.triangular(q10, q50, q90, size=size)


def load_data():
    if not os.path.exists(GEN_CSV):
        raise FileNotFoundError(f"Generated dataset not found: {GEN_CSV}")
    if not os.path.exists(RANGE_CSV):
        raise FileNotFoundError(f"ResStock summary not found: {RANGE_CSV}")
    gen = pd.read_csv(GEN_CSV)
    ranges = pd.read_csv(RANGE_CSV)
    return gen, ranges


def ecdf(x: np.ndarray):
    x = np.sort(x)
    n = len(x)
    y = np.arange(1, n + 1) / n
    return x, y


def get_resstock_stats(summary_df: pd.DataFrame, metric: str):
    sub = summary_df[summary_df["metric"] == metric]
    if sub.empty:
        return None
    row = sub.iloc[0]
    # Some summaries might be missing fields; handle robustly
    q10 = float(row.get("q10", np.nan))
    q50 = float(row.get("q50", np.nan))
    q90 = float(row.get("q90", np.nan))
    mean = float(row.get("mean", np.nan))
    std = float(row.get("std", np.nan))
    return q10, q50, q90, mean, std


def plot_one(name: str,
             gen_vals: np.ndarray,
             q10: float,
             q50: float,
             q90: float,
             mean: float,
             xlabel: str,
             out_path: str):
    if gen_vals.size == 0:
        print(f"[skip] {name}: no generated data.")
        return

    x, y = ecdf(gen_vals)

    plt.figure(figsize=(6, 4))

    # Generated ECDF
    plt.plot(x, y, linewidth=2, label="Generated homes")

    # ResStock 10–90% band
    if not np.isnan(q10) and not np.isnan(q90) and q10 < q90:
        plt.axvspan(q10, q90, alpha=0.15, label="ResStock 10-90%")

    # ResStock median
    if not np.isnan(q50):
        plt.axvline(q50, linestyle="--", linewidth=1.5, label="ResStock median")

    # ResStock mean
    if not np.isnan(mean):
        plt.axvline(mean, linestyle=":", linewidth=1.8, label="ResStock mean")

    # Coverage metric: % of generated samples within [q10, q90]
    coverage = np.nan
    if not np.isnan(q10) and not np.isnan(q90) and q10 < q90:
        coverage = ((gen_vals >= q10) & (gen_vals <= q90)).mean() * 100.0

    title = f"{name} realism"
    if not np.isnan(coverage):
        title += f" (coverage: {coverage:.1f}% in 10–90%)"

    plt.title(title)
    plt.xlabel(xlabel)
    plt.ylabel("ECDF")
    plt.grid(alpha=0.2)
    plt.legend(loc="lower right")
    plt.tight_layout()
    plt.savefig(out_path, dpi=300)
    plt.close()

    if not np.isnan(coverage):
        print(f"[ok] {name}: saved {out_path} (coverage {coverage:.1f}% in 10–90%)")
    else:
        print(f"[ok] {name}: saved {out_path} (no valid 10–90% band; plotted ECDF only)")
    return coverage


def plot_hist_overlay(name: str,
                      gen_vals: np.ndarray,
                      ref_vals: np.ndarray,
                      q10: float,
                      q90: float,
                      xlabel: str,
                      out_path: str):
    """Overlay histograms of generated values and a ResStock reference sample.

    Note: `ref_vals` is an approximate ResStock reference distribution constructed
    from quantiles (see `sample_from_quantiles`).
    """
    if gen_vals.size == 0:
        print(f"[skip] {name}: no generated data for histogram.")
        return

    plt.figure(figsize=(6, 4))

    # Use a shared binning so the two histograms are directly comparable.
    all_vals = gen_vals
    if ref_vals is not None and ref_vals.size > 0:
        all_vals = np.concatenate([gen_vals, ref_vals])

    # Robust bin count (avoid too many bins for small samples)
    n_bins = int(np.clip(np.sqrt(all_vals.size), 15, 60))

    plt.hist(gen_vals, bins=n_bins, density=True, alpha=0.55, label="Generated homes")

    if ref_vals is not None and ref_vals.size > 0:
        plt.hist(ref_vals, bins=n_bins, density=True, alpha=0.35,
                 label="ResStock ref (triangular approx)")

    # ResStock 10–90% band for visual context
    if not np.isnan(q10) and not np.isnan(q90) and q10 < q90:
        plt.axvspan(q10, q90, alpha=0.12, label="ResStock 10-90%")

    plt.title(f"{name} histogram overlay")
    plt.xlabel(xlabel)
    plt.ylabel("Density")
    plt.grid(alpha=0.2)
    plt.legend(loc="best")
    plt.tight_layout()
    plt.savefig(out_path, dpi=300)
    plt.close()
    print(f"[ok] {name}: saved {out_path} (hist overlay)")


def plot_boxplots(name: str,
                  gen_vals: np.ndarray,
                  ref_vals: np.ndarray,
                  q10: float,
                  q50: float,
                  q90: float,
                  xlabel: str,
                  out_path: str):
    """Side-by-side boxplots of generated values and a ResStock reference sample.

    Note: `ref_vals` is an approximate ResStock reference distribution constructed
    from quantiles (see `sample_from_quantiles`).
    """
    if gen_vals.size == 0:
        print(f"[skip] {name}: no generated data for boxplot.")
        return

    data = [gen_vals]
    labels = ["Generated homes"]

    if ref_vals is not None and ref_vals.size > 0:
        data.append(ref_vals)
        labels.append("ResStock ref\n(triangular approx)")

    plt.figure(figsize=(6, 4))
    plt.boxplot(data, tick_labels=labels, showfliers=True)

    # Draw ResStock quantile markers for context (only if provided)
    # These are x-positioned at the ResStock box (2) if it exists, else at 1.
    x_pos = 2 if (ref_vals is not None and ref_vals.size > 0) else 1
    if not np.isnan(q10):
        plt.scatter([x_pos], [q10], marker="o", s=25, label="ResStock q10")
    if not np.isnan(q50):
        plt.scatter([x_pos], [q50], marker="D", s=25, label="ResStock q50")
    if not np.isnan(q90):
        plt.scatter([x_pos], [q90], marker="o", s=25, label="ResStock q90")

    plt.title(f"{name} boxplot comparison")
    plt.ylabel(xlabel)
    plt.grid(alpha=0.2, axis="y")
    # Keep legend from covering boxes when only one distribution is present
    if (not np.isnan(q10)) or (not np.isnan(q50)) or (not np.isnan(q90)):
        plt.legend(loc="best")
    plt.tight_layout()
    plt.savefig(out_path, dpi=300)
    plt.close()
    print(f"[ok] {name}: saved {out_path} (boxplot)")


def main():
    gen, ranges = load_data()
    rows = []

    for name, gen_col, metric, xlabel in VARIABLES:
        if gen_col not in gen.columns:
            print(f"[skip] {name}: generated column '{gen_col}' not found in {GEN_CSV}")
            continue

        stats = get_resstock_stats(ranges, metric)
        if stats is None:
            print(f"[skip] {name}: metric '{metric}' not found in {RANGE_CSV}")
            continue

        q10, q50, q90, rs_mean, rs_std = stats

        vals = (
            gen[gen_col]
            .astype(float)
            .replace([np.inf, -np.inf], np.nan)
            .dropna()
            .values
        )

        if vals.size == 0:
            print(f"[skip] {name}: all values NaN/invalid after cleaning.")
            continue

        syn_std = float(np.std(vals, ddof=1)) if vals.size > 1 else np.nan

        # Build a synthetic reference sample from q10/q50/q90 for KS testing
        ref = sample_from_quantiles(q10, q50, q90, size=max(2000, vals.size * 5))
        if ref.size > 0:
            res = ks_2samp(vals, ref, alternative="two-sided", mode="auto")
            ks_D, ks_p = float(res.statistic), float(res.pvalue)
            n_ref = int(ref.size)
        else:
            ks_D, ks_p = (np.nan, np.nan)
            n_ref = 0

        out_path = os.path.join(OUT_DIR, f"ecdf_{name}.png")
        coverage = plot_one(name, vals, q10, q50, q90, rs_mean, xlabel, out_path)

        # Histogram overlay and boxplot comparisons against an approximate ResStock reference
        out_hist = os.path.join(OUT_DIR, f"hist_overlay_{name}.png")
        plot_hist_overlay(name, vals, ref, q10, q90, xlabel, out_hist)

        out_box = os.path.join(OUT_DIR, f"boxplot_{name}.png")
        plot_boxplots(name, vals, ref, q10, q50, q90, xlabel, out_box)

        rows.append({
            "variable": name,
            "n_gen": int(vals.size),
            "n_ref": n_ref,
            "q10": q10,
            "q50": q50,
            "q90": q90,
            "resstock_mean": float(rs_mean) if not np.isnan(rs_mean) else np.nan,
            "resstock_std": float(rs_std) if not np.isnan(rs_std) else np.nan,
            "synthetic_std": syn_std,
            "coverage_pct": float(coverage) if not np.isnan(coverage) else np.nan,
            "ks_D": float(ks_D) if not np.isnan(ks_D) else np.nan,
            "ks_p": float(ks_p) if not np.isnan(ks_p) else np.nan,
        })

    # Write per-variable summary CSV
    if rows:
        report_path = os.path.join(OUT_DIR, "realism_summary.csv")
        pd.DataFrame(rows).to_csv(report_path, index=False)
        print(f"[ok] Wrote summary CSV: {report_path}")
    else:
        print("[warn] No variables processed; no summary CSV written.")


if __name__ == "__main__":
    main()
